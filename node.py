#import Queue
import collections
from event import *
from main import Simulator

class Node(object):
    ''' Provides the 'node' abstraction. Because we need to simulate two types of 
    cong ctrl/scheduling policies, the layout of node class is aimed at separating out 
    the policy related logic (i.e. bufferMan and congCtrl, which tends to change) '''
    def __init__(self, node_id, cong_ctrl): # these two argument are base class references
        self._id = node_id
        self.congctrl = cong_ctrl

        self.src = None
        self.sink = None

        self.nbrs = []
        self.weights = [] # corresponding to each link where self is one of the vertices
        self.buf_man = {} # next hop node id : buf_man. next_hop_id is in the meantime buf_man.id

        self.next_hop = {} # dst_id : next_hop_id
        #self.ifs = []
    def id(self):
        return self._id

    def nextHopDic(self):
        return self.next_hop

    def attachBufMan(self, buf_man):
        self.buf_man[buf_man.id()] = buf_man
        #self.buf_man.attachNode(self)

    def getBufManByDst(self, dst_id):
        if dst_id not in self.next_hop or self.next_hop[dst_id] not in self.buf_man:
            raise ValueError('Node:getBufMan: buf man not found')
        return self.buf_man[self.next_hop[dst_id]]

    def getNextHop(self, dst_id):
        assert dst_id in self.next_hop
        return self.next_hop[dst_id]

    def attachSrc(self, src):
        self.src = src

    def attachSink(self, sink):
        self.sink = sink

    def schedule(self):
        ''' if the planned sending is granted by next hop, send it; otherwise, congestion control is in effect '''
        pass 

    def send(self):
        pass

    def receive(self, chunk):
        ''' a chunk will be enqueued at one of the buffers, by the link layer buffer manager. The chunk may come 
            from a higher layer buffer (app buffer), or from another node. '''
        print 'receive called'

        # if cur node is dst, send it to sink, else enqueue at link buffer manager
        if chunk.dst() == self._id:
            # sink should handle it
            self.sink.finish(chunk)
        else:
            # find out the next hop for this chunk (i.e. corresponding buf_man)
            next_hop = self.next_hop[chunk.dst()]

            # then call corresponding buf_man's enqueue
            self.buf_man[next_hop].enqueue(chunk)
        
    def addNbr(self, nbr):
        self.nbrs.append(nbr)
    def addWeight(self, weight):
        self.weights.append(weight)

    def getNbrList(self):
        return self.nbrs

class TrafficSrc(object):
    def __init__(self, node, cong_ctrl):
        self._node = node
        self.app_buf_man = None
        #Buffer() # in addition to the bufferMan which manages multiple link layer buffers, src node has app
                                    # buffer which has traffic generated by application
    def attachBufMan(self, buf_man):
        self.app_buf_man = buf_man 

    def pushAppBuffer(self, chunk):
        self.app_buf_man.enqueue(chunk)

    def downOneChunk(self, dst_id):
        chunk = self.app_buf_man.dequeue(dst_id)
        if not chunk:
            print 'TrafficSrc: no available chunk for dst_id: %d' % (dst_id,)
        else:
            self._node.receive(chunk)

        return chunk
            

class TrafficSink:
    def __init__(self, node):
        self._node = node

    def finish(self, chunk):
        print 'TrafficSink:finish, node %d' % (self._node.id())
        chunk.show()
    

class BaseBuffer: # buffer could be for a single interface, or for a single flow
    def __init__(self, node, buf_id, capa=0):
        self.buf_id = buf_id
        self.max_bytes = capa # max capacity in bytes
        self.cur_bytes = 0
        self.queue = collections.deque()
        self.cur_node = node
        # buffer scheduling cycle, blocking time
        
        self.next_sched = 0.0 # in millisecond
        self.sched_intv = 0.1 # 1MB chunk per 0.1ms, i.e. default is 10GB/s 

        self.cong_ctrl = cong_ctrl

    def startBlocking(self): # this should be an observe() function in a observer: once a corresponding congestion
                            # signal is active, the current buffer is blocked.
        pass
       
    def enqueue(self, chunk):
        #self.queue.put(chunk)
        self.queue.append(chunk)
        self.increCurBytes(chunk.size())
        self.cong_ctrl.updateState()
        #self.curNode(cur_node)
        print 'BaseBuffer:enqueue the chunk'

    def dequeue(self):
        ''' before dequeue, generate a new event for next interval, and insert it onto evt queue. '''
        self.insertEvent() 
        #return self.queue.get()
        return self.queue.popleft()

    def empty(self):
        return False if self.queue else True

    def peek(self):
        return self.queue[0]

    def numBytes(self):
        return self.cur_bytes

    def numChunks(self):
        return len(self.queue)

    def increCurBytes(self, inc):
        self.cur_bytes += inc

    def decreCurBytes(self, dec):
        self.cur_bytes -= dec
    
    def insertEvent(self):
        pass

    # cong control related operations
    def congCtrl(self):
        return self.cong_ctrl

    def attachCongObserver(self, obs_buf):
        self.cong_ctrl.attach(obs_buf)

class AppBuffer(BaseBuffer):
    def insertEvent(self):
        #evt = DownStackEvt(self._node, self.buf_id)
        #Simulator().enqueue(evt)
        pass

class LinkBuffer(BaseBuffer):
    def insertEvent(self):
        pass

class LinkBufferPerFlow(LinkBuffer):
    def enqueue(self, chunk):
        pass

    def attachObserver(self):
        pass

class BaseBufferManager(object):
    def __init__(self, simu, id):
        self._node = None
        self._id = id
        self._buffers = {}  # id : buffer, id means differently in different context: next hop, or dst id
        self._simulator = simu
        

    def id(self):
        return self._id

    def addBuffer(self, buf_id):
        self._buffers[buf_id] = BaseBuffer(self._node, buf_id)

    def getBufById(self, buf_id):
        return self._buffers[buf_id]

    def attachNode(self, node):
        self._node = node

    def node(self):
        return self._node 

    def enqueue(self, chunk):
        pass

    def dequeue(self, buf_id):
        if buf_id not in self._buffers:
            raise KeyError('buf_id: %d' % (buf_id,))

        chunk = None
        if self.canDequeue(buf_id):
            buf = self._buffers[buf_id] 
            if not buf.empty():
                chunk = buf.dequeue()
        return chunk


    def canDequeue(self, buf_id): 
        ''' given an index to a buffer, determine if we can dequeue a chunk (i.e. not blocked) from it. Returns a boolean '''
        return True


    def receive(self, chunk):
        ''' receive some data: increment buffer occupancy counter '''
        pass

    def send(self):
        pass

class AppBufferManager(BaseBufferManager):
    def enqueue(self, chunk):
        dst_id = chunk.dst() 
        if dst_id not in self._buffers:
            self.addBuffer(dst_id)

            # for every destination, downStackEvt is created once initially
            evt = DownStackEvt(self._simulator, 0.0, self._node, dst_id)
            self._simulator.enqueue(evt)

        self._buffers[dst_id].enqueue(chunk)

class LinkBufferManager(BaseBufferManager):
    def __init__(self, simu, id, band, lat):
        super(LinkBufferManager, self).__init__(simu, id)
        self._band = band # bandwidth, unit: byte per ms
        self._lat = lat # latency: between self._node and the next hop which this buffer is for
        self._intv = 10 # length of scheduling interval in ms, later can change this to 1,000,000/band

    def schedInterval(self, chunk=None):
        if chunk is None:
            return self._intv
        else:
            return chunk.size()/self._band 
         
    def schedBuffer(self): 
        ''' return a buf_id of which we will send a chunk from '''
        pass

    def schedNextTx(self):
        pass
    

class LinkBufferManagerPerFlow(LinkBufferManager):
    def __init__(self, simu, id, band, lat):
        super(LinkBufferManagerPerFlow, self).__init__(simu, id, band, lat)
        self._buf_ids = []
        self._last_buf_ind = 0

    def addBuffer(self, buf_id):
        cong_ctrl = CongControllerPerFlow()
        self._buffers[buf_id] = LinkBufferPerFlow(self._node, buf_id, cong_ctrl)

    def enqueue(self, chunk):
        print 'linkBufManPerFlow: enqueue'
        dst_id = chunk.dst() 
        if dst_id not in self._buffers:
            self.addBuffer(dst_id)
        
        buf = self._buffers[dst_id]
        self._buffers[dst_id].enqueue(chunk)

        # if last hop is not in cong_ctrl's observers, attach it
        print 'linkBufManPerFlow: enqueue a chunk at node %d buf_man %d buf %d' \
                % (self._node._id, self._id, dst_id)

    def schedBuffer(self):
        ''' Round Robin scheduling. If there's an available buffer with data in it, schedule it; else if no such buffer exist,
            return -1. '''
        self._buf_ids = self._buffers.keys()
        if not self._buf_ids: return -1
        temp_ind = self._last_buf_ind + 1
        while True: 
            cur_id = self._buf_ids[temp_ind % len(self._buf_ids)]
            buf = self._buffers[cur_id]
            if not buf.empty(): 
                # if current time is after the scheduled Tx time
                chunk = buf.peek()
                print 'LinkBufferManagerPerFlow:schedBuf: chunk start time: %f, sim time: %f' \
                    % (chunk.startTimestamp(), self._simulator.time())
                if chunk.startTimestamp() <= self._simulator.time() and \
                    not buf.congCtrl().isBlockedOut(self._simulator.time()):
                    self._last_buf_ind = temp_ind % len(self._buf_ids)
                    return cur_id
            if cur_id == self._buf_ids[self._last_buf_ind]:  # we've checked all buffers
                return -1
            temp_ind += 1

class LinkBufferManagerPerIf(LinkBufferManager):
    ''' per interface queuing '''
    def enqueue(self, chunk):
        ''' enqueue based on next hop, instead of dst '''
        pass

