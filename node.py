import Queue
from event import *
from main import Simulator

class Node(object):
    ''' Provides the 'node' abstraction. Because we need to simulate two types of 
    cong ctrl/scheduling policies, the layout of node class is aimed at separating out 
    the policy related logic (i.e. bufferMan and congCtrl, which tends to change) '''
    def __init__(self, node_id, cong_ctrl): # these two argument are base class references
        self.id = node_id
        self.buf_man = None
        self.congctrl = cong_ctrl

        self.src = None
        self.sink = None

        self.nbrs = []
        self.ifs = []

    def attachBufMan(self, buf_man):
        self.buf_man = buf_man
        self.buf_man.attachNode(self)

    def attachSrc(self, src):
        self.src = src

    def attachSink(self, sink):
        self.sink = sink

    def schedule(self):
        ''' if the planned sending is granted by next hop, send it; otherwise, congestion control is in effect '''
        pass 

    def send(self):
        pass

    def receive(self, chunk):
        ''' a chunk will be enqueued at one of the buffers, by the link layer buffer manager. The chunk may come 
            from a higher layer buffer (app buffer), or from another node. '''
        buf_man.enqueue(chunk)
        
    def addNbr(self, nbr):
        self.nbrs.append(nbr)

    def getNbrList(self):
        return self.nbrs

class TrafficSrc(object):
    def __init__(self, node, cong_ctrl):
        self.node = node
        self.app_buf_man = None
        #Buffer() # in addition to the bufferMan which manages multiple link layer buffers, src node has app
                                    # buffer which has traffic generated by application
    def attachBufMan(self, buf_man):
        self.app_buf_man = buf_man 

    def pushAppBuffer(self, chunk):
        self.app_buf_man.enqueue(chunk)

    def downOneChunk(self, dst_id):
        chunk = self.app_buf_man.dequeue(dst_id)
        if not chunk:
            print 'TrafficSrc: no available chunk for dst_id: %d' % (dst_id,)
        else:
            self.node.receive(chunk)

        return chunk
            

class TrafficSink:
    def __init__(self):
        pass
    

class BaseBuffer: # buffer could be for a single interface, or for a single flow
    def __init__(self, node, buf_id, capa=0):
        self.buf_id = buf_id
        self.max_bytes = capa # max capacity in bytes
        self.cur_bytes = 0
        self.queue = Queue.Queue() # queue of chunks
        self.cur_node = node
        # buffer scheduling cycle, blocking time
        
        self.next_sched = 0.0 # in millisecond
        self.sched_intv = 0.1 # 1MB chunk per 0.1ms, i.e. default is 10GB/s 

    def startBlocking(self): # this should be an observe() function in a observer: once a corresponding congestion
                            # signal is active, the current buffer is blocked.
        pass
       
    def enqueue(self, chunk):
        self.queue.put(chunk)
        self.increCurBytes(chunk.size())
        #self.curNode(cur_node)

    def dequeue(self):
        ''' before dequeue, generate a new event for next interval, and insert it onto evt queue. '''
        self.insertEvent() 
        return self.queue.get()

    def empty(self):
        return self.queue.empty()

    def getCurBytes(self):
        return self.cur_bytes

    def increCurBytes(self, inc):
        self.cur_bytes += inc

    def decreCurBytes(self, dec):
        self.cur_bytes -= dec
    
    def insertEvent(self):
        pass

class AppBuffer(BaseBuffer):
    def insertEvent(self):
        evt = DownStackEvt(self.node, self.buf_id)
        Simulator().enqueue(evt)

class LinkBuffer(BaseBuffer):
    def insertEvent(self):
        pass

class BaseBufferManager(object):
    def __init__(self, simu):
        self.node = None
        self.buffers = {}  # id : buffer, id means differently in different context: next hop, or dst id
        self.simulator = simu

    def addBuffer(self, buf_id):
        self.buffers[buf_id] = BaseBuffer(self.node, buf_id)

    def attachNode(self, node):
        self.node = node

    def enqueue(self, chunk):
        pass

    def dequeue(self, buf_id):
        if buf_id not in self.buffers:
            raise KeyError('buf_id: %d' % (buf_id,))

        chunk = None
        if self.canDequeue(buf_id):
            buf = self.buffers[buf_id] 
            if not buf.empty():
                chunk = buf.dequeue()
        return chunk

    def canDequeue(self, buf_id): 
        ''' given an index to a buffer, determine if we can dequeue a chunk (i.e. not blocked) from it. Returns a boolean '''
        return True

    def receive(self, chunk):
        ''' receive some data: increment buffer occupancy counter '''
        pass

    def send(self):
        pass

class AppBufferManager(BaseBufferManager):
    def enqueue(self, chunk):
        dst_id = chunk.dst() 
        if dst_id not in self.buffers:
            self.addBuffer(dst_id)

            # for every destination, downStackEvt is created once initially
            evt = DownStackEvt(chunk.timestamp(), self.node, dst_id)
            self.simulator.enqueue(evt)

        self.buffers[dst_id].enqueue(chunk)

class LinkBufferManagerPerFlow(BaseBufferManager):
    def enqueue(self, chunk):
        dst_id = chunk.dst() 
        if dst_id not in self.buffers:
            self.addBuffer(dst_id)
        
        buf = self.buffers[dst_id]
        if buf.empty():
            # at this point, chunk's ts is time of arrival at this node
            evt = TxEvt(chunk.timestamp(), self.node, dst_id)
            self.simulator.enqueue(evt)

        self.buffers[dst_id].enqueue(chunk)

class LinkBufferManagerPerIf(BaseBufferManager):
    ''' per interface queuing '''
    def enqueue(self, chunk):
        ''' enqueue based on next hop, instead of dst '''
        pass
    



class ICongController:
    ''' The whole graph will only need one instance of CongController ''' 
    def signal(self): 
        ''' signal a specific node about the congestion, it could ask a particular node to resend after some time. '''
        pass
